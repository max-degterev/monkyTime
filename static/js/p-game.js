// Generated by CoffeeScript 1.4.0

(function($) {
  var Entity, Player, block, btoa, engine, game, highscore, leadZeros, log, md5, options, scoreboard, screens, win;
  if (!Date.now) {
    Date.now = function() {
      return +new Date();
    };
  }
  scoreboard = [];
  highscore = 0;
  $.ajax({
    url: '/api/v1.1/game/score.json',
    type: 'GET',
    success: function(res) {
      if (res.length) {
        scoreboard = res;
        return highscore = scoreboard[0].score;
      }
    }
  });
  options = {
    debug: true,
    lives: 6,
    garbage: 5 * 1000,
    player: {
      step: 10,
      accel: 1
    },
    modes: {
      time: 1000 * 20,
      speeds: [5, 8, 12, 16, 23, 25],
      accelerated: 3,
      randomized: 6,
      vector: 2
    },
    sudden: {
      active: true,
      objects: ['banana', 'banana', 'bomb', 'bomb', 'heart'],
      num: 15
    },
    transform: S.utils.supports('transform'),
    objects: {
      banana: {
        "class": 'banana',
        chance: .25,
        num: 7,
        points: 1,
        lives: 0,
        accel: 1
      },
      bomb: {
        "class": 'bomb',
        chance: .005,
        num: 3,
        points: -5,
        lives: -2,
        accel: 2
      },
      heart: {
        "class": 'heart',
        chance: .0001,
        num: 1,
        points: 30,
        lives: 2,
        accel: 3
      }
    }
  };
  log = function() {
    if (options.debug && (window.console != null)) {
      if (arguments.length > 1) {
        return console.log(Array.prototype.slice.call(arguments));
      } else {
        return console.log(arguments[0]);
      }
    }
  };
  md5 = window.md5;
  btoa = window.btoa;
  delete window.md5;
  delete window.atob;
  delete window.btoa;
  leadZeros = function(num) {
    if (num < 10) {
      return '00' + num;
    }
    if (num < 100) {
      return '0' + num;
    }
    return '' + num;
  };
  block = $('.p-game');
  win = $(window);
  screens = (function() {
    var els, limitNameToChars, nameEl, saveScore, scoreboardEl, showGame, showHighScore, showIntro, showOver, updateScoreboard;
    els = block.find('.game-screen');
    scoreboardEl = block.find('.game-scoreboard');
    nameEl = block.find('#game-player-name');
    showIntro = function() {
      els.filter('.active').removeClass('active');
      els.filter('.game-intro').addClass('active');
      block.trigger('game::intro');
      return log('game::screens::intro');
    };
    showOver = function() {
      els.filter('.active').removeClass('active');
      els.filter('.game-over').addClass('active').find('.game-results-final').html(leadZeros(game.score));
      nameEl.off('keydown', limitNameToChars);
      block.trigger('game::over');
      return log('game::screens::over');
    };
    showHighScore = function() {
      els.filter('.active').removeClass('active');
      els.filter('.game-highscore').addClass('active').find('.game-results-final').html(leadZeros(game.score));
      nameEl.on('keydown', limitNameToChars);
      block.trigger('game::highscore');
      return log('game::screens::highscore');
    };
    showGame = function() {
      els.filter('.active').removeClass('active');
      els.filter('.game-mainscreen').addClass('active');
      block.trigger('game::started');
      return log('game::screens::game');
    };
    updateScoreboard = function() {
      var item, results;
      results = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = scoreboard.length; _i < _len; _i++) {
          item = scoreboard[_i];
          _results.push('<li>' + item.name + ' ' + leadZeros(item.score) + '</li>');
        }
        return _results;
      })();
      return scoreboardEl.html(results);
    };
    saveScore = function() {
      var json, result, val;
      if (!((val = $.trim(nameEl.val())).length && game.score > highscore)) {
        return;
      }
      result = {
        name: val,
        score: game.score
      };
      scoreboard.unshift(result);
      if (!(scoreboard.length <= 10)) {
        scoreboard.length = 10;
      }
      highscore = game.score;
      json = JSON.stringify(result);
      $.ajax({
        url: '/api/v1.1/game/score.json',
        data: {
          signature: md5(json),
          data: btoa(json)
        },
        type: 'POST',
        success: function(res) {
          scoreboard = res;
          return highscore = scoreboard[0].score;
        }
      });
      updateScoreboard();
      return showOver();
    };
    limitNameToChars = function(e) {
      if (e.keyCode === 13) {
        return saveScore();
      } else {
        if (!/^[a-zA-Z]*$/.test(String.fromCharCode(e.keyCode)) && e.keyCode !== 8 && e.keyCode !== 46) {
          return e.preventDefault();
        }
      }
    };
    updateScoreboard();
    block.find('#game-start').on('click', showGame);
    block.find('#game-retry').on('click', showGame);
    block.find('#game-savescore').on('click', saveScore);
    return {
      intro: showIntro,
      over: showOver,
      highscore: showHighScore,
      game: showGame
    };
  })();
  game = (function() {
    var calculateOffset, defaults;
    defaults = {
      active: false,
      score: 0,
      lives: options.lives,
      mode: 0,
      objects: [],
      activeObjects: {},
      player: null,
      time: Date.now(),
      timeDelta: 0,
      width: block.width(),
      height: block.height(),
      offset: {},
      keys: {
        esc: false,
        left: false,
        right: false,
        mouseX: 0,
        mouseY: 0
      }
    };
    defaults.reset = function() {
      game.active = false;
      game.score = 0;
      game.lives = options.lives;
      return game.mode = 0;
    };
    calculateOffset = function() {
      var pos;
      pos = block.offset();
      defaults.offset.x = pos.left;
      return defaults.offset.y = pos.top;
    };
    calculateOffset();
    win.on('resize', calculateOffset);
    return defaults;
  })();
  Entity = (function() {

    function Entity(type, settings) {
      this.type = type;
      this.options = settings;
      this.points = this.options.points;
      this.lives = this.options.lives;
      this.chance = this.options.chance;
      this.velocity = 0;
      this.accelerated = 0;
      this.vector = 0;
      this.randomized = 0;
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.remove = false;
      this.active = false;
      this.el = $('<span class="game-object ' + this.options["class"] + '"></span>');
    }

    Entity.prototype.getSizes = function() {
      this.width = this.el.width();
      return this.height = this.el.height();
    };

    Entity.prototype.activate = function() {
      this.active = true;
      this.el.addClass('active');
      if (!this.remove) {
        game.activeObjects[this.type]++;
      }
      if (!(this.width && this.height)) {
        this.getSizes();
      }
      this.x = Math.random() * (game.width - this.width);
      return this.y = -Math.random() * game.height;
    };

    Entity.prototype.deactivate = function() {
      this.x = 0;
      this.y = 0;
      this.active = false;
      this.el.removeClass('active');
      if (!this.remove) {
        game.activeObjects[this.type]--;
      }
      this.velocity = 0;
      return this.vector = 0;
    };

    Entity.prototype._randomVector = function() {
      return (Math.random() < .5 ? this.options.accel : -this.options.accel) * (Math.random() + 1);
    };

    Entity.prototype.move = function() {
      if (game.mode >= options.modes.accelerated - 1 && game.time - this.accelerated > 150) {
        this.velocity += this.options.accel;
        this.accelerated = game.time;
      }
      if (game.mode >= options.modes.vector - 1 && game.mode < options.modes.randomized - 1 && !this.vector) {
        this.vector = this._randomVector();
      }
      if (game.mode >= options.modes.randomized - 1 && game.time - this.randomized > 300) {
        this.vector += this._randomVector() * 3;
        this.randomized = game.time;
      }
      this.y += options.modes.speeds[game.mode] + this.velocity;
      this.x += this.vector;
      if (this.y >= game.height) {
        return this.deactivate();
      }
    };

    Entity.prototype.render = function() {
      var props;
      if (!this.active && !this.remove) {
        if (game.activeObjects[this.type] >= options.objects[this.type].num) {
          return false;
        }
        if (Math.random() < this.chance || this.chance === 1) {
          this.activate();
        } else {
          return false;
        }
      }
      this.move();
      if (options.transform) {
        props = {};
        props[options.transform] = 'translate3d(' + this.x + 'px, ' + this.y + 'px, 0)';
      } else {
        props = {
          left: this.x,
          top: this.y
        };
      }
      return this.el.css(props);
    };

    return Entity;

  })();
  Player = (function() {

    function Player() {
      this.x = 0;
      this.y = 0;
      this.el = block.find('.player');
      this.width = 0;
      this.height = 0;
      this.velocity = 0;
      this.moved = 0;
      this.offset = parseInt($(this.el).css('margin-top'));
    }

    Player.prototype.reset = function() {
      this.width = this.el.width();
      this.height = this.el.height();
      this.x = (game.width / 2) - (this.el.width() / 2);
      this.y = 0;
      return this.move(0, 0);
    };

    Player.prototype.update = function() {
      var breakValue, direction, force, forceValue;
      forceValue = 5800;
      breakValue = 10;
      force = 0;
      if (game.useMouse) {
        forceValue *= 2;
        breakValue *= 1.5;
        direction = game.keys.mouseX - game.player.x - game.player.width / 2 - game.offset.x;
        if (Math.abs(direction) < 10) {
          direction = 0;
        } else if (direction > 0) {
          force = forceValue;
        } else if (direction < 0) {
          force = -forceValue;
        }
      } else {
        if (game.keys.left) {
          force = -forceValue;
        } else if (game.keys.right) {
          force = forceValue;
        }
      }
      force -= breakValue * this.velocity;
      this.velocity += force * game.timeDelta;
      this.x += this.velocity * game.timeDelta;
      return this.x = Math.max(0, Math.min(game.width - this.width, this.x));
    };

    Player.prototype.move = function(x, keyb) {
      if (x != null) {
        if (keyb) {
          if (game.time - this.moved < 100) {
            this.velocity += x > 0 ? options.player.accel : -options.player.accel;
          } else {
            this.velocity = 0;
          }
        } else {
          this.velocity = 0;
        }
        this.x = Math.min(Math.max(0, this.x + x + this.velocity), game.width - this.width);
        return this.moved = game.time;
      }
    };

    Player.prototype.render = function() {
      var props;
      if (options.transform) {
        props = {};
        props[options.transform] = 'translate3d(' + this.x + 'px, ' + this.y + 'px, 0)';
      } else {
        props = {
          left: this.x,
          top: this.y
        };
      }
      return this.el.css(props);
    };

    return Player;

  })();
  engine = (function() {
    var changeMode, checkCollisions, collision, doc, el, frame, gameLoop, gameOver, garbageCollected, garbageCollector, handleKeys, handleMouse, initEngine, initObjects, initSudden, livesEl, modeStarted, modesNum, pauseEl, pauseEngine, render, resetObjects, resumeEngine, scoreEl, startEngine, stopEngine, stopLoop, togglePause;
    doc = $(document);
    el = block.find('.game-mainscreen');
    livesEl = block.find('.game-lives');
    scoreEl = block.find('.game-score');
    pauseEl = block.find('.game-paused');
    modeStarted = Date.now();
    modesNum = options.modes.speeds.length - 1;
    garbageCollected = Date.now();
    frame = null;
    initObjects = function() {
      var ent, obj, type, _i, _ref, _ref1;
      _ref = options.objects;
      for (type in _ref) {
        obj = _ref[type];
        game.activeObjects[type] = 0;
        for (_i = 1, _ref1 = obj.num; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--) {
          ent = new Entity(type, obj);
          el.append(ent.el);
          game.objects.push(ent);
        }
      }
      return game.player = new Player();
    };
    initSudden = function() {
      var ent, _i, _ref, _results;
      _results = [];
      for (_i = 1, _ref = options.sudden.num; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--) {
        ent = new Entity(options.sudden.objects[game.mode], options.objects[options.sudden.objects[game.mode]]);
        ent.remove = true;
        el.append(ent.el);
        ent.activate();
        _results.push(game.objects.push(ent));
      }
      return _results;
    };
    initEngine = function() {
      initObjects();
      block.on('game::started', startEngine);
      pauseEl.on('click', togglePause);
      return log('game::engine::initialized');
    };
    resetObjects = function() {
      var obj, _i, _len, _ref, _results;
      _ref = game.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        _results.push(obj.deactivate());
      }
      return _results;
    };
    collision = function(obj) {
      if (obj.points) {
        game.score = Math.max(game.score + obj.points, 0);
        scoreEl.html(leadZeros(game.score));
      }
      if (obj.lives) {
        game.lives = Math.min(game.lives + obj.lives, options.lives);
        livesEl.attr('data-lives', game.lives);
        if (game.lives <= 0) {
          gameOver();
        }
      }
      return obj.deactivate();
    };
    checkCollisions = function(obj) {
      if (((obj.y + obj.height >= game.player.y + game.player.offset) && (obj.y <= game.player.y + game.player.offset)) || ((obj.y >= game.player.y + game.player.offset) && (obj.y <= game.player.y + game.player.offset + game.player.height))) {
        if (((obj.x <= game.player.x) && (obj.x + obj.width >= game.player.x)) || ((obj.x >= game.player.x) && (obj.x <= game.player.x + game.player.width))) {
          return collision(obj);
        }
      }
    };
    changeMode = function() {
      modeStarted = game.time;
      if (!!options.sudden.active) {
        initSudden();
      }
      game.mode++;
      return log('game::engine::mode ' + (game.mode + 1));
    };
    garbageCollector = function() {
      var collected, ent, gameObjects, _i, _len, _ref;
      garbageCollected = game.time;
      gameObjects = [];
      collected = 0;
      _ref = game.objects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ent = _ref[_i];
        if (ent.remove && !ent.active) {
          ent.el.remove();
          collected++;
        } else {
          gameObjects.push(ent);
        }
      }
      game.objects = gameObjects;
      return log('game::engine::gc collected: ' + collected);
    };
    render = function() {
      var ent, _i, _len, _ref, _results;
      game.player.update();
      game.player.render();
      _ref = game.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ent = _ref[_i];
        if (!!ent.active) {
          checkCollisions(ent);
        }
        _results.push(ent.render());
      }
      return _results;
    };
    gameLoop = function() {
      var now;
      if (game.active) {
        frame = requestAnimationFrame(gameLoop);
        now = Date.now();
        game.timeDelta = (now - game.time) * 0.001;
        game.time = now;
        if (game.time - modeStarted > options.modes.time && modesNum > game.mode) {
          changeMode();
        }
        render();
      }
      if (game.time - garbageCollected > options.garbage) {
        return garbageCollector();
      }
    };
    stopLoop = function() {
      return cancelAnimationFrame(frame);
    };
    handleKeys = function(e) {
      var codes, _ref;
      codes = {
        27: 'esc',
        37: 'left',
        39: 'right',
        65: 'left',
        68: 'right'
      };
      if (!(codes[e.keyCode] != null)) {
        return;
      }
      game.keys[codes[e.keyCode]] = (_ref = e.type === 'keydown') != null ? _ref : {
        "true": false
      };
      if (game.keys.esc) {
        console.log('toggle');
        togglePause();
      }
      return game.useMouse = false;
    };
    handleMouse = function(e) {
      game.keys.mouseX = e.pageX;
      game.keys.mouseY = e.pageY;
      return game.useMouse = true;
    };
    gameOver = function() {
      stopEngine();
      if (game.score > highscore) {
        return screens.highscore();
      } else {
        return screens.over();
      }
    };
    togglePause = function() {
      if (game.active) {
        return pauseEngine();
      } else {
        return resumeEngine();
      }
    };
    startEngine = function() {
      doc.on('keydown', handleKeys);
      doc.on('keyup', handleKeys);
      doc.on('mousemove', handleMouse);
      win.on('blur', pauseEngine);
      livesEl.attr('data-lives', game.lives);
      scoreEl.html(leadZeros(game.score));
      modeStarted = Date.now();
      resetObjects();
      game.reset();
      game.player.reset();
      game.active = true;
      gameLoop();
      return log('game::engine::started');
    };
    stopEngine = function() {
      doc.off('keydown', handleKeys);
      doc.off('keyup', handleKeys);
      doc.off('mousemove', handleMouse);
      win.off('blur', pauseEngine);
      game.active = false;
      stopLoop();
      return log('game::engine::stopped');
    };
    pauseEngine = function() {
      el.addClass('paused');
      game.active = false;
      stopLoop();
      return log('game::engine::paused');
    };
    resumeEngine = function() {
      el.removeClass('paused');
      game.active = true;
      gameLoop();
      return log('game::engine::resumed');
    };
    return {
      init: initEngine,
      start: startEngine,
      stop: stopEngine,
      pause: startEngine,
      resume: startEngine
    };
  })();
  return engine.init();
})(jQuery);
